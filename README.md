# CS-330

1. How do I approach designing software?

This project was one of the most challenging assignments during my time at SNHU. I have never built 3D rendered objects and I had to restart many times during this build. Using the skills to build simple shape objects I learned at the beginning of this course, I was able to add additional assets on those pieces until I had comprehensive and dynamic objects to insert into my scene. I had to refer often to the Open GL documentation to use trial and error to get the objects into the correct space for my scene, and it took researching other examples to learn how the scale and position of these shape meshes should build together. Looking ahead to future projects using 3D animation and rendering, I want to really understand the building blocks in a situation like this before tackling more advanced design principles. 

2. How do I approach developing programs?

At this point in my development career, I feel that I have a sound understanding of taking initial project constraints and making a coding plan to meet the needed objectives. However, in this course I had to go back to the sample GL project over and over again to see how an example scene would come together and use that logic to craft my own scene. Having the milestones throughout the course helped me see the building blocks formed to build a complete scene, and I would not have been successful without revisiting some of those earlier builds. I think in future projects beyond 3D rendering and animation, I want to revert to the documentation more and study other examples to gain insight into how these builds come together.

3. How can computer science help me in reaching my goals?

Computational graphics and visualizations has helped me learned more patience and debugging skills in my computer science journey, to not rush through development without first understanding how the initial pieces are crafted and how they interact with each other to build complex scenes. These new skills and frameworks will help me in future development cycles to make incremental progress throughout the build to reach a more comprehensive final product.

